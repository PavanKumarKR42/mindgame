<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=390, initial-scale=1.0" />
  <title>Mind Color Sequence Game</title>

    <meta name="fc:miniapp" content='{
    "version":"1",
    "imageUrl":"https://mindgame-omega.vercel.app/image.png",
    "splashImageUrl": "https://mindgame-omega.vercel.app/splash.png",
    "button":{
      "title":"BRAIN.exe!",
      "action":{
        "type":"launch_frame",
        "name":"Mind Color Sequence",
        "url":"https://mindgame-omega.vercel.app/",
        "splashImageUrl":"https://mindgame-omega.vercel.app/splash.png",
        "splashBackgroundColor":"#ffd753"
      }
    }
  }' />

  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    button:focus { outline: none; }
    button:active { outline: none; }
    
    html, body {
      width: 100%;
      min-height: 100vh;
      overflow-x: hidden;
      overflow-y: auto;
    }
    
    body {
      display: flex; 
      flex-direction: column; 
      align-items: center; 
      justify-content: flex-start;
      background: #0a0e27;
      position: relative;
      font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
      color: #fff;
      padding: 20px; 
      max-width: 390px; 
      margin: 0 auto;
    }
    
    body::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: 
        radial-gradient(ellipse at top left, rgba(138, 43, 226, 0.15), transparent 50%),
        radial-gradient(ellipse at top right, rgba(0, 191, 255, 0.15), transparent 50%),
        radial-gradient(ellipse at bottom, rgba(255, 20, 147, 0.1), transparent 50%);
      pointer-events: none;
      z-index: 0;
      animation: bgPulse 8s ease-in-out infinite;
    }
    
    @keyframes bgPulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }
    
    body::after {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-image: 
        repeating-linear-gradient(0deg, rgba(255,255,255,0.03) 0px, transparent 1px, transparent 2px, rgba(255,255,255,0.03) 3px),
        repeating-linear-gradient(90deg, rgba(255,255,255,0.03) 0px, transparent 1px, transparent 2px, rgba(255,255,255,0.03) 3px);
      pointer-events: none;
      z-index: 1;
    }
    
    body > * {
      position: relative;
      z-index: 2;
    }
    
    .tabbar { 
      display: flex; 
      gap: 10px; 
      width: 100%; 
      margin: 12px 0 20px; 
      background: rgba(255, 255, 255, 0.03);
      padding: 6px;
      border-radius: 16px;
      backdrop-filter: blur(20px);
      border: 1px solid rgba(255, 255, 255, 0.08);
    }
    
    .tabbar button { 
      flex: 1; 
      padding: 12px; 
      background: transparent;
      border: none;
      color: rgba(255, 255, 255, 0.5);
      border-radius: 12px; 
      font-weight: 700; 
      font-size: 14px;
      cursor: pointer; 
      transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      position: relative;
      overflow: hidden;
    }
    
    .tabbar button::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(135deg, rgba(138, 43, 226, 0.4), rgba(0, 191, 255, 0.4));
      opacity: 0;
      transition: opacity 0.4s ease;
    }
    
    .tabbar button.active {
      color: #fff;
      text-shadow: 0 0 20px rgba(138, 43, 226, 0.8);
    }
    
    .tabbar button.active::before {
      opacity: 1;
    }
    
    .hidden { display: none; }
    
    .game-container { 
      background: rgba(255, 255, 255, 0.03);
      backdrop-filter: blur(20px);
      border-radius: 24px; 
      padding: 24px; 
      box-shadow: 
        0 8px 32px rgba(0, 0, 0, 0.4),
        inset 0 1px 0 rgba(255, 255, 255, 0.1),
        0 0 100px rgba(138, 43, 226, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.08);
      width: 100%; 
      margin-bottom: 20px;
      position: relative;
    }
    
    .game-container::before {
      content: '';
      position: absolute;
      top: -2px;
      left: -2px;
      right: -2px;
      bottom: -2px;
      background: linear-gradient(45deg, 
        rgba(138, 43, 226, 0.5), 
        rgba(0, 191, 255, 0.5),
        rgba(255, 20, 147, 0.5));
      border-radius: 24px;
      opacity: 0;
      transition: opacity 0.4s ease;
      z-index: -1;
      filter: blur(10px);
    }
    
    .game-container:hover::before {
      opacity: 0.3;
    }
    
    h1 { 
      text-align: center; 
      margin-bottom: 20px; 
      font-size: 28px; 
      font-weight: 900;
      background: linear-gradient(135deg, #8a2be2, #00bfff, #ff1493);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      letter-spacing: 1px;
      position: relative;
      animation: titleGlow 3s ease-in-out infinite;
    }
    
    @keyframes titleGlow {
      0%, 100% { filter: drop-shadow(0 0 10px rgba(138, 43, 226, 0.5)); }
      50% { filter: drop-shadow(0 0 25px rgba(0, 191, 255, 0.8)); }
    }
    
    .score-info { 
      display: flex; 
      justify-content: center; 
      margin-bottom: 24px; 
    }
    
    .score-box { 
      background: rgba(255, 255, 255, 0.05);
      padding: 10px 24px; 
      border-radius: 16px; 
      text-align: center; 
      border: 1px solid rgba(255, 255, 255, 0.1);
      position: relative;
      overflow: hidden;
    }
    
    .score-box::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
      transition: left 0.8s ease;
    }
    
    .score-box:hover::before {
      left: 100%;
    }
    
    .score-label { 
      font-size: 11px; 
      opacity: 0.6; 
      text-transform: uppercase; 
      letter-spacing: 2px;
      font-weight: 600;
    }
    
    .score-value { 
      font-size: 32px; 
      font-weight: 900; 
      margin-top: 8px;
      background: linear-gradient(135deg, #00bfff, #8a2be2);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    
    #colorDisplay { 
      width: 100%; 
      height: 150px; 
      border-radius: 20px; 
      margin-bottom: 24px; 
      border: 2px solid rgba(255, 255, 255, 0.1);
      display: flex; 
      align-items: center; 
      justify-content: center; 
      font-size: 24px; 
      font-weight: 900; 
      background: rgba(0, 0, 0, 0.4);
      transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: 
        inset 0 4px 20px rgba(0, 0, 0, 0.3),
        0 8px 32px rgba(0, 0, 0, 0.3);
      text-shadow: 0 2px 10px rgba(0, 0, 0, 0.8);
      position: relative;
      overflow: hidden;
    }
    
    #colorDisplay::after {
      content: '';
      position: absolute;
      top: -50%;
      left: -50%;
      width: 200%;
      height: 200%;
      background: radial-gradient(circle, rgba(255, 255, 255, 0.1), transparent 70%);
      animation: rotate 8s linear infinite;
    }
    
    @keyframes rotate {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }
    
    #colorDisplay.pulse { 
      animation: pulse 0.5s ease; 
    }
    
    @keyframes pulse { 
      0%, 100% { transform: scale(1); } 
      50% { 
        transform: scale(1.03);
        box-shadow: 
          inset 0 4px 20px rgba(0, 0, 0, 0.3),
          0 8px 32px rgba(0, 0, 0, 0.3),
          0 0 40px currentColor;
      } 
    }
    
    .buttons { 
      display: grid; 
      grid-template-columns: repeat(3, 1fr); 
      gap: 14px; 
      margin-bottom: 60px; 
      position: relative; 
    }
    
    .bonk-token { 
      position: absolute; 
      width: 55px; 
      height: 55px; 
      border-radius: 50%; 
      object-fit: cover; 
      border: 3px solid rgba(255, 215, 0, 0.9);
      box-shadow: 
        0 8px 25px rgba(0, 0, 0, 0.4), 
        0 0 40px rgba(255, 215, 0, 0.6),
        inset 0 0 20px rgba(255, 215, 0, 0.3);
      top: 85px; 
      left: 50%; 
      transform: translateX(-50%); 
      z-index: 10; 
      animation: float 3s ease-in-out infinite;
      filter: drop-shadow(0 0 15px rgba(255, 215, 0, 0.8));
    }
    
    @keyframes float { 
      0%, 100% { transform: translateX(-50%) translateY(0px) rotate(0deg); } 
      50% { transform: translateX(-50%) translateY(-12px) rotate(5deg); } 
    }
    
    .colorBtn { 
      height: 70px; 
      border: 2px solid;
      border-radius: 16px; 
      cursor: pointer; 
      font-weight: 900; 
      font-size: 13px; 
      color: #fff; 
      text-shadow: 0 2px 8px rgba(0, 0, 0, 0.8);
      transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
      position: relative; 
      overflow: hidden; 
      letter-spacing: 1px;
      text-transform: uppercase;
    }
    
    .colorBtn[data-color="red"] { 
      background: linear-gradient(135deg, #e74c3c, #c0392b);
      border-color: #ff6b6b;
      box-shadow: 
        0 6px 20px rgba(231, 76, 60, 0.4),
        inset 0 1px 0 rgba(255, 255, 255, 0.2),
        0 0 20px rgba(231, 76, 60, 0.3);
    }
    
    .colorBtn[data-color="blue"] { 
      background: linear-gradient(135deg, #3498db, #2980b9);
      border-color: #74b9ff;
      box-shadow: 
        0 6px 20px rgba(52, 152, 219, 0.4),
        inset 0 1px 0 rgba(255, 255, 255, 0.2),
        0 0 20px rgba(52, 152, 219, 0.3);
    }
    
    .colorBtn[data-color="green"] { 
      background: linear-gradient(135deg, #2ecc71, #27ae60);
      border-color: #55efc4;
      box-shadow: 
        0 6px 20px rgba(46, 204, 113, 0.4),
        inset 0 1px 0 rgba(255, 255, 255, 0.2),
        0 0 20px rgba(46, 204, 113, 0.3);
    }
    
    .colorBtn[data-color="yellow"] { 
      background: linear-gradient(135deg, #f39c12, #d68910);
      border-color: #fdcb6e;
      box-shadow: 
        0 6px 20px rgba(243, 156, 18, 0.4),
        inset 0 1px 0 rgba(255, 255, 255, 0.2),
        0 0 20px rgba(243, 156, 18, 0.3);
    }
    
    .colorBtn[data-color="purple"] { 
      background: linear-gradient(135deg, #9b59b6, #7d3c98);
      border-color: #a29bfe;
      box-shadow: 
        0 6px 20px rgba(155, 89, 182, 0.4),
        inset 0 1px 0 rgba(255, 255, 255, 0.2),
        0 0 20px rgba(155, 89, 182, 0.3);
    }
    
    .colorBtn::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.3), transparent 60%);
      opacity: 1;
      pointer-events: none;
    }
    
    .colorBtn::after { 
      content: ''; 
      position: absolute; 
      top: -50%; 
      left: -150%; 
      width: 200%; 
      height: 200%; 
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
      transform: skewX(-20deg);
      transition: left 0.6s ease;
    }
    
    .colorBtn:hover:not(:disabled)::after { 
      left: 150%; 
    }
    
    .colorBtn:hover:not(:disabled) { 
      transform: translateY(-6px) scale(1.05); 
      box-shadow: 
        0 12px 40px rgba(0, 0, 0, 0.5), 
        0 0 50px currentColor,
        inset 0 1px 0 rgba(255, 255, 255, 0.3);
      filter: brightness(1.2) saturate(1.2);
    }
    
    .colorBtn:active:not(:disabled) { 
      transform: translateY(-2px) scale(0.98); 
    }
    
    .colorBtn:disabled { 
      opacity: 0.3; 
      cursor: not-allowed; 
      filter: grayscale(0.7);
    }
    
    .colorBtn.purple-btn { 
      grid-column: 3; 
      grid-row: 2; 
    }
    
    .colorBtn.pressed { 
      animation: press 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55); 
    }
    
    @keyframes press { 
      0% { transform: scale(1) rotate(0deg); } 
      25% { transform: scale(0.9) rotate(-4deg); } 
      50% { 
        transform: scale(0.95) rotate(2deg); 
        filter: brightness(1.5) saturate(1.5);
        box-shadow: 0 0 50px currentColor;
      } 
      75% { transform: scale(0.9) rotate(-2deg); } 
      100% { transform: scale(1) rotate(0deg); } 
    }
    
    #message { 
      text-align: center; 
      font-size: 16px; 
      min-height: 30px; 
      font-weight: 600; 
      text-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
      margin-bottom: 20px;
      color: rgba(255, 255, 255, 0.9);
    }
    
    .btn-control {
  display: flex;
  flex-direction: column;
  gap: 12px;
  width: 100%;
}

    
    .restart-btn, .start-btn { 
      flex: 1; 
      padding: 14px; 
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.15);
      border-radius: 14px; 
      color: white; 
      font-size: 14px; 
      font-weight: 700; 
      cursor: pointer; 
      transition: all 0.3s ease;
      backdrop-filter: blur(10px);
      position: relative;
      overflow: hidden;
    }
    
    .restart-btn::before, .start-btn::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 0;
      height: 0;
      background: rgba(255, 255, 255, 0.2);
      border-radius: 50%;
      transform: translate(-50%, -50%);
      transition: width 0.4s ease, height 0.4s ease;
    }
    
    .restart-btn:hover::before, .start-btn:hover::before {
      width: 300px;
      height: 300px;
    }
    
    .restart-btn:hover, .start-btn:hover { 
      background: rgba(255, 255, 255, 0.1);
      border-color: rgba(255, 255, 255, 0.3);
      transform: translateY(-2px);
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
    }
    
    .claim-btn { 
      flex: 1; 
      padding: 14px; 
      background: linear-gradient(135deg, #2ecc71, #27ae60);
      border: 1px solid rgba(255, 255, 255, 0.3);
      border-radius: 14px; 
      color: white; 
      font-size: 14px; 
      font-weight: 700; 
      cursor: pointer; 
      transition: all 0.3s ease;
      box-shadow: 
        0 6px 20px rgba(46, 204, 113, 0.4),
        inset 0 1px 0 rgba(255, 255, 255, 0.2);
      position: relative;
      overflow: hidden;
    }
    
    .claim-btn::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
      transition: left 0.5s ease;
    }
    
    .claim-btn:hover::before {
      left: 100%;
    }
    
    .claim-btn:hover { 
      background: linear-gradient(135deg, #27ae60, #229954);
      transform: translateY(-3px);
      box-shadow: 0 10px 30px rgba(46, 204, 113, 0.6);
    }
    
    table { 
      width: 100%; 
      border-collapse: collapse; 
      margin-top: 12px; 
      background: rgba(255, 255, 255, 0.03);
      backdrop-filter: blur(20px);
      border-radius: 20px; 
      overflow: hidden; 
      box-shadow: 
        0 8px 32px rgba(0, 0, 0, 0.4),
        inset 0 1px 0 rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.08);
    }
    
    th, td { 
      padding: 18px 14px; 
      border-bottom: 1px solid rgba(255, 255, 255, 0.05);
      font-size: 14px; 
      text-align: left; 
    }
    
    th { 
      background: rgba(255, 255, 255, 0.08);
      font-weight: 700; 
      text-transform: uppercase; 
      letter-spacing: 1.5px;
      font-size: 11px; 
      color: rgba(255, 255, 255, 0.8);
    }
    
    tbody tr { 
      transition: all 0.3s ease; 
      background: rgba(255, 255, 255, 0.02);
    }
    
    tbody tr:hover { 
      background: rgba(255, 255, 255, 0.08);
      transform: translateX(4px);
    }
    
    tbody tr:last-child td { 
      border-bottom: none; 
    }
    
    .center { 
      text-align: center; 
    }
    
    .rank-cell { 
      font-weight: 900; 
      font-size: 20px; 
      width: 50px; 
      text-align: center;
    }
    
    .rank-cell.gold { 
      filter: drop-shadow(0 0 10px rgba(255, 215, 0, 0.8));
    }
    
    .rank-cell.silver { 
      filter: drop-shadow(0 0 10px rgba(192, 192, 192, 0.8));
    }
    
    .rank-cell.bronze { 
      filter: drop-shadow(0 0 10px rgba(205, 127, 50, 0.8));
    }
    
    .user-cell { 
      display: flex; 
      align-items: center; 
      gap: 14px; 
    }
    
    .pfp { 
      width: 44px; 
      height: 44px; 
      border-radius: 50%; 
      object-fit: cover; 
      border: 2px solid rgba(255, 255, 255, 0.2);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      transition: all 0.3s ease;
    }
    
    .pfp:hover { 
      transform: scale(1.15);
      border-color: rgba(138, 43, 226, 0.8);
      box-shadow: 0 6px 20px rgba(138, 43, 226, 0.5);
    }
    
    .user-info { 
      display: flex; 
      flex-direction: column; 
    }
    
    .username { 
      font-weight: 700; 
      font-size: 14px; 
      color: #fff;
    }
    
    .address { 
      font-size: 11px; 
      opacity: 0.5;
      font-family: 'Courier New', monospace; 
    }
    
    .score-cell { 
      font-weight: 900; 
      font-size: 22px; 
      text-align: center;
      background: linear-gradient(135deg, #2ecc71, #00bfff);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      filter: drop-shadow(0 2px 8px rgba(46, 204, 113, 0.4));
    }
    
    .leaderboard-header { 
      text-align: center; 
      margin-bottom: 20px; 
      padding: 24px; 
      background: rgba(255, 255, 255, 0.03);
      backdrop-filter: blur(20px);
      border-radius: 20px; 
      border: 1px solid rgba(255, 255, 255, 0.08);
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
    }
    
    .leaderboard-header h3 { 
      font-size: 32px; 
      margin-bottom: 10px;
      background: linear-gradient(135deg, #FFD700, #FFA500, #ff1493);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      filter: drop-shadow(0 2px 15px rgba(255, 215, 0, 0.6));
      font-weight: 900;
    }
    
    .leaderboard-header p { 
      font-size: 13px; 
      opacity: 0.7;
      margin: 0; 
    }
    
    .toast { 
      position: fixed; 
      bottom: 14px; 
      left: 50%; 
      transform: translateX(-50%);
      background: rgba(255, 255, 255, 0.08);
      backdrop-filter: blur(20px);
      color: #fff; 
      border: 1px solid rgba(255, 255, 255, 0.15);
      border-radius: 16px; 
      padding: 12px 18px; 
      font-weight: 600; 
      max-width: 360px; 
      width: calc(100% - 24px);
      box-shadow: 0 12px 40px rgba(0, 0, 0, 0.6);
      display: none; 
      z-index: 9999;
      font-size: 14px;
    }
    
    .toast.show { 
      display: block; 
      animation: fadeIn 0.3s ease; 
    }
    
    @keyframes fadeIn { 
      from { 
        opacity: 0; 
        transform: translate(-50%, 20px); 
      } 
      to { 
        opacity: 1; 
        transform: translate(-50%, 0); 
      } 
    }
    
    .confetti { 
      position: fixed; 
      width: 10px; 
      height: 10px; 
      background: #f39c12;
      animation: fall 3s linear forwards; 
      z-index: 10000;
      border-radius: 2px;
    }
    
    @keyframes fall { 
      to { 
        transform: translateY(100vh) rotate(720deg); 
        opacity: 0; 
      } 
    }

    /* Rules Modal Styles */
    .rules-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.85);
      backdrop-filter: blur(10px);
      z-index: 9998;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
      opacity: 0;
      animation: fadeInOverlay 0.4s ease forwards;
    }

    @keyframes fadeInOverlay {
      to { opacity: 1; }
    }

    .rules-overlay.hidden {
      display: none;
    }

    .rules-container {
      background: rgba(10, 14, 39, 0.95);
      backdrop-filter: blur(20px);
      border-radius: 24px;
      padding: 32px 28px;
      max-width: 450px;
      width: 100%;
      border: 1px solid rgba(255, 255, 255, 0.15);
      box-shadow: 
        0 20px 60px rgba(0, 0, 0, 0.6),
        inset 0 1px 0 rgba(255, 255, 255, 0.1);
      position: relative;
      animation: slideUp 0.5s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
      max-height: 85vh;
      overflow-y: auto;
    }

    @keyframes slideUp {
      from {
        transform: translateY(50px);
        opacity: 0;
      }
      to {
        transform: translateY(0);
        opacity: 1;
      }
    }

    .rules-header {
      margin-bottom: 24px;
    }

    .rules-title {
      font-size: 28px;
      font-weight: 900;
      background: linear-gradient(135deg, #8a2be2, #00bfff, #ff1493);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      text-align: center;
    }

    .rules-content {
      color: rgba(255, 255, 255, 0.9);
      line-height: 1.8;
      font-size: 15px;
    }

    .rules-content p {
      margin-bottom: 20px;
      display: flex;
      align-items: flex-start;
      gap: 12px;
    }

    .rules-content p:last-child {
      margin-bottom: 0;
    }

    .rules-bullet {
      color: #00bfff;
      font-size: 20px;
      line-height: 1.4;
      flex-shrink: 0;
    }

    .rules-text {
      flex: 1;
    }
.share-btn {
  width: 100%;
  padding: 14px 20px;
  background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%);
  color: #fff;
  border: none;
  border-radius: 12px;
  font-weight: 800;
  font-size: 16px;
  cursor: pointer;
  transition: all 0.3s ease;
  box-shadow: 0 4px 12px rgba(139, 92, 246, 0.4);
  display: none; /* Use display: none instead of hidden class */
}

.share-btn:hover:not(:disabled) {
  transform: translateY(-2px);
  box-shadow: 0 8px 20px rgba(139, 92, 246, 0.6);
}

.share-btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}
.share-btn.hidden {
  display: none;
}

    .rules-text strong {
      color: #fff;
      font-weight: 700;
    }

    .rules-close-btn {
      width: 100%;
      padding: 14px;
      background: linear-gradient(135deg, #8a2be2, #00bfff);
      border: 1px solid rgba(255, 255, 255, 0.3);
      border-radius: 14px;
      color: white;
      font-size: 15px;
      font-weight: 700;
      cursor: pointer;
      transition: all 0.3s ease;
      margin-top: 24px;
      box-shadow: 0 6px 20px rgba(138, 43, 226, 0.4);
    }

    .rules-close-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 10px 30px rgba(138, 43, 226, 0.6);
    }
  </style>
</head>
<body>

  <!-- Rules Overlay -->
  <div class="rules-overlay" id="rulesOverlay">
    <div class="rules-container">
      <div class="rules-header">
        <h2 class="rules-title">Game Rules</h2>
      </div>
      
      <div class="rules-content">
        <p>
          <span class="rules-bullet">•</span>
          <span class="rules-text"><strong>You get 3 games per day.</strong> That's right, <strong>THREE.</strong> No more, no less. Don't waste 'em trying to be smart. Just play, loser 😎</span>
        </p>
        <p>
          <span class="rules-bullet">•</span>
          <span class="rules-text"><strong>Each game has 7 rounds.</strong> Think of it like 7 boss fights, except the bosses are your own bad decisions.</span>
        </p>
        <p>
          <span class="rules-bullet">•</span>
          <span class="rules-text"><strong>Reach Round 7 = YOU WIN LIFE.</strong> Congratulations, you absolute legend 🎉 You get <strong>3,000 $BONK tokens</strong> — enough to brag on Farcaster for at least 12 hours.</span>
        </p>
        <p>
          <span class="rules-bullet">•</span>
          <span class="rules-text"><strong>Don't make it to Round 7?</strong> Oof. Tough luck. Your score gets <strong>thrown onto the leaderboard</strong> so everyone can laugh — or cheer, if they're nice (they're not).</span>
        </p>
        <p>
          <span class="rules-bullet">•</span>
          <span class="rules-text"><strong>Leaderboard = Street Cred.</strong> More score = more flex. Less score = meme material.</span>
        </p>
      </div>
      
      <button class="rules-close-btn" id="gotItBtn">Got It! Let's Play 🚀</button>
    </div>
  </div>

  <div class="tabbar">
    <button id="tabPlayBtn" class="active">Play</button>
    <button id="tabLbBtn">Leaderboard</button>
  </div>

  <section id="playTab">
    <div class="game-container">
      <h1>Mind Color Sequence</h1>
      
      <div class="score-info">
        <div class="score-box">
          <div class="score-label">Round</div>
          <div class="score-value" id="roundDisplay">1</div>
        </div>
      </div>
      
      <div id="colorDisplay">GET READY</div>
      
      <div class="buttons" id="buttonsContainer">
        <img src="bonktoken.png" alt="BONK" class="bonk-token">
      </div>
      
      <div id="message"></div>
      
      <div class="btn-control">
        <button class="start-btn" id="connectBtn">Connect Wallet</button>
        <button class="start-btn hidden" id="startBtn">Start Free Game</button>
        <button class="restart-btn hidden" id="restartBtn">Restart Game</button>
        <button class="claim-btn hidden" id="claimBtn">Claim 3k BONK</button>
          <button class="share-btn hidden" id="shareBtn">🎉 Share Your Win on Farcaster</button>

      </div>

    </div>
  </section>

  <section id="leaderboardTab" class="hidden" style="width:100%;padding:0 12px;margin-bottom:20px;">
    <div class="leaderboard-header">
      <h3>🏆 Top Players 🏆</h3>
      <p>Compete for the highest score and claim your glory!</p>
    </div>
    <table>
      <thead><tr><th style="text-align: center;">Rank</th><th>Player</th><th style="text-align: center;">Score</th></tr></thead>
      <tbody id="leaderboardBody"><tr><td colspan="3" class="center">Loading…</td></tr></tbody>
    </table>
  </section>

  <div id="toast" class="toast"></div>

 <script type="module">
    import { sdk } from 'https://esm.sh/@farcaster/miniapp-sdk';
    import {
      createConfig, connect, readContract, writeContract, getAccount
    } from 'https://esm.sh/@wagmi/core';
    import { arbitrum } from 'https://esm.sh/@wagmi/core/chains';
    import { farcasterMiniApp } from 'https://esm.sh/@farcaster/miniapp-wagmi-connector';
    import { createPublicClient, http } from 'https://esm.sh/viem';
    import { decodeEventLog } from 'https://esm.sh/viem';

    /* ---------- Config ---------- */
    const CONTRACT_ADDRESS = '0xe54be4a16ec396d2c31812a3693af15281ee115a';
    const MAX_SCORE = 7;
    const NEYNAR_API_KEY = '20FEAD29-CB14-438B-8309-868BA126B594';
    const GAME_URL = 'https://mindgame-omega.vercel.app/'; // Replace with your actual game URL

    const ABI =[{"inputs":[{"internalType":"address","name":"_bonkToken","type":"address"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"gameId","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"score","type":"uint256"}],"name":"GameEnded","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"player","type":"address"},{"indexed":true,"internalType":"uint256","name":"gameId","type":"uint256"}],"name":"GameStarted","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"gameId","type":"uint256"}],"name":"RewardClaimed","type":"event"},{"inputs":[],"name":"MAX_DAILY_GAMES","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"MAX_SCORE","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"REWARD","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"","type":"uint256"}],"name":"allPlayers","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"bonkToken","outputs":[{"internalType":"contract IERC20","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"gameId","type":"uint256"}],"name":"claim","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"dailyPlays","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"gameId","type":"uint256"},{"internalType":"uint256","name":"score","type":"uint256"}],"name":"endGame","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"","type":"uint256"}],"name":"games","outputs":[{"internalType":"address","name":"player","type":"address"},{"internalType":"bool","name":"ended","type":"bool"},{"internalType":"uint256","name":"score","type":"uint256"},{"internalType":"bool","name":"claimed","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"n","type":"uint256"}],"name":"getTopPlayers","outputs":[{"internalType":"address[]","name":"","type":"address[]"},{"internalType":"uint256[]","name":"","type":"uint256[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"lastDay","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"nextGameId","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"startGame","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"userTotalScore","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"withdraw","outputs":[],"stateMutability":"nonpayable","type":"function"}];

    const config = createConfig({
      chains: [arbitrum],
      transports: { [arbitrum.id]: http() }
    });

    const publicClient = createPublicClient({
      chain: arbitrum,
      transport: http()
    });

    /* ---------- UI Refs ---------- */
    const playTab = document.getElementById('playTab');
    const leaderboardTab = document.getElementById('leaderboardTab');
    const tabPlayBtn = document.getElementById('tabPlayBtn');
    const tabLbBtn = document.getElementById('tabLbBtn');
    const toastEl = document.getElementById('toast');
    const claimBtn = document.getElementById('claimBtn');
    const shareBtn = document.getElementById('shareBtn');
    const restartBtn = document.getElementById('restartBtn');
    const startBtn = document.getElementById('startBtn');
    const connectBtn = document.getElementById('connectBtn');
    const colorDisplay = document.getElementById('colorDisplay');
    const buttonsContainer = document.getElementById('buttonsContainer');
    const message = document.getElementById('message');
    const roundDisplay = document.getElementById('roundDisplay');

    /* ---------- State ---------- */
    let userAddress = null;
    let currentGameId = null;
    let currentDailyPlays = 0;
    let maxDailyGames = 3;
    let finalScore = 0;

    tabPlayBtn.onclick = () => {
      playTab.classList.remove('hidden');
      leaderboardTab.classList.add('hidden');
      tabPlayBtn.classList.add('active');
      tabLbBtn.classList.remove('active');
    };

    tabLbBtn.onclick = () => {
      leaderboardTab.classList.remove('hidden');
      playTab.classList.add('hidden');
      tabLbBtn.classList.add('active');
      tabPlayBtn.classList.remove('active');
      loadLeaderboard();
    };

    function showToast(html, ms = 3500) {
      toastEl.innerHTML = html;
      toastEl.classList.add('show');
      setTimeout(() => toastEl.classList.remove('show'), ms);
    }

    function updateStartButtonText(dailyPlays) {
      if (dailyPlays < maxDailyGames) {
        startBtn.innerText = `Start Free Game (${dailyPlays}/${maxDailyGames})`;
        startBtn.disabled = false;
        if (timerInterval) {
          clearInterval(timerInterval);
          timerInterval = null;
        }
      } else {
        startBtn.disabled = true;
        startTimer();
      }
    }

   async function fetchDailyPlays(address) {
      try {
        const currentDay = Math.floor(Date.now() / 1000 / 86400);
        
        const lastDay = await readContract(config, {
          address: CONTRACT_ADDRESS,
          abi: ABI,
          functionName: 'lastDay',
          args: [address]
        });
        
        if (Number(lastDay) < currentDay) {
          currentDailyPlays = 0;
        } else {
          const count = await readContract(config, {
            address: CONTRACT_ADDRESS,
            abi: ABI,
            functionName: 'dailyPlays',
            args: [address]
          });
          currentDailyPlays = Number(count);
        }
        
        updateStartButtonText(currentDailyPlays);
      } catch (e) {
        console.error('Failed to fetch daily plays:', e);
        currentDailyPlays = 0;
        updateStartButtonText(currentDailyPlays);
      }
    }

    async function fetchMaxDailyGames() {
      try {
        const max = await readContract(config, {
          address: CONTRACT_ADDRESS,
          abi: ABI,
          functionName: 'MAX_DAILY_GAMES'
        });
        maxDailyGames = Number(max);
      } catch (e) {
        console.error('Failed to fetch MAX_DAILY_GAMES:', e);
        maxDailyGames = 3;
      }
    }

    /* ---------- Initialize SDK and Wallet ---------- */
    sdk.actions.ready({ disableNativeGestures: true }).then(async () => {
      console.log("Farcaster MiniApp ready");
      message.innerText = "Ready to connect!";
      
      // Show rules on first visit
      const hasSeenRules = localStorage.getItem('hasSeenRules');
      if (!hasSeenRules) {
        setTimeout(() => {
          document.getElementById('rulesOverlay').classList.remove('hidden');
        }, 300);
      }

      // Auto-prompt to add app (only once per session)
      const hasPromptedAddApp = sessionStorage.getItem('hasPromptedAddApp');
      if (!hasPromptedAddApp) {
        try {
          console.log('Auto-prompting add app...');
          await sdk.actions.addMiniApp();
          sessionStorage.setItem('hasPromptedAddApp', 'true');
          console.log('App added successfully!');
        } catch (error) {
          console.log('Add app prompt dismissed or failed:', error.name);
          sessionStorage.setItem('hasPromptedAddApp', 'true');
        }
      }

    }).catch(err => {
      console.error("SDK ready error:", err);
      message.innerText = "SDK initialization failed";
      showToast("Failed to initialize. Try reloading.");
    });

    // Rules overlay controls
    const rulesOverlay = document.getElementById('rulesOverlay');
    const gotItBtn = document.getElementById('gotItBtn');

    function closeRules() {
      rulesOverlay.classList.add('hidden');
      localStorage.setItem('hasSeenRules', 'true');
    }

    gotItBtn.onclick = closeRules;

    connectBtn.onclick = async () => {
      try {
        connectBtn.disabled = true;
        connectBtn.innerText = 'Connecting...';
        message.innerText = "Connecting wallet...";

        await connect(config, {
          connector: farcasterMiniApp(),
          chainId: arbitrum.id
        });

        userAddress = getAccount(config)?.address;

        if (userAddress) {
          showToast(`Connected: ${userAddress.slice(0, 6)}…${userAddress.slice(-4)}`);
          
          await fetchMaxDailyGames();
          await fetchDailyPlays(userAddress);

          connectBtn.classList.add('hidden');
          startBtn.classList.remove('hidden');
          colorDisplay.innerText = "Get Ready...";
          message.innerText = "Wallet connected. Ready to play!";
        } else {
          throw new Error("No address returned");
        }
      } catch (err) {
        console.error("Wallet connect failed:", err);
        showToast("Connect failed. Make sure you opened this in Warpcast.");
        connectBtn.disabled = false;
        connectBtn.innerText = 'Connect Wallet';
        message.innerText = "Connection failed. Try again.";
      }
    };

    claimBtn.onclick = async () => {
      if (!currentGameId) {
        showToast('No active game to claim. Play and win first!');
        return;
      }
      
      if (finalScore !== MAX_SCORE) {
        showToast(`Score must be exactly ${MAX_SCORE} to claim. You scored ${finalScore}.`);
        return;
      }
      
      try {
        claimBtn.disabled = true;
        claimBtn.innerText = 'Checking...';
        
        const gameData = await readContract(config, {
          address: CONTRACT_ADDRESS,
          abi: ABI,
          functionName: 'games',
          args: [BigInt(currentGameId)]
        });
        
        console.log('Game data:', gameData);
        const [player, ended, score, claimed] = gameData;
        
        if (claimed) {
          showToast('Reward already claimed for this game!');
          claimBtn.classList.add('hidden');
          return;
        }
        
        if (!ended) {
          showToast('Game not ended yet. Please wait.');
          claimBtn.disabled = false;
          claimBtn.innerText = 'Claim 3k BONK';
          return;
        }
        
        if (Number(score) !== MAX_SCORE) {
          showToast(`Score is ${Number(score)}, must be exactly ${MAX_SCORE} to claim!`);
          claimBtn.disabled = false;
          claimBtn.innerText = 'Claim 3k BONK';
          return;
        }
        
        const bonkAddress = await readContract(config, {
          address: CONTRACT_ADDRESS,
          abi: ABI,
          functionName: 'bonkToken'
        });
        
        const contractBalance = await readContract(config, {
          address: bonkAddress,
          abi: [{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"balanceOf","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"}],
          functionName: 'balanceOf',
          args: [CONTRACT_ADDRESS]
        });
        
        console.log('Contract BONK balance:', contractBalance.toString());
        
        const requiredReward = 3000000n;
        if (contractBalance < requiredReward) {
          showToast('Contract has insufficient BONK tokens. Contact developer to refill!', 5000);
          claimBtn.disabled = false;
          claimBtn.innerText = 'Claim 3k BONK';
          return;
        }
        
        claimBtn.innerText = 'Claiming...';
        const txResponse = await writeContract(config, {
          address: CONTRACT_ADDRESS,
          abi: ABI,
          functionName: 'claim',
          args: [BigInt(currentGameId)]
        });
        
        const hash = txResponse?.hash || txResponse;
        
        if (!hash) {
          throw new Error('Transaction failed - no hash returned');
        }
        
        showToast(`Claim TX sent! <a target="_blank" href="https://arbiscan.io/tx/${hash}" style="color: #2ecc71; text-decoration: underline;">View TX</a>`, 5000);
        message.innerText = 'Waiting for confirmation...';
        
        await publicClient.waitForTransactionReceipt({ hash });
        
        // Transaction confirmed - show success and show share button
        showToast(`🎉 Reward claimed successfully! 3k BONK is yours!`, 4000);
        message.innerText = `Successfully claimed 3k BONK tokens!`;
        claimBtn.classList.add('hidden');
        
        // Show share button after successful claim
        if (shareBtn) {
          shareBtn.style.display = 'block';
        }
        
      } catch (e) {
        console.error('Claim error:', e);
        let errMsg = e?.shortMessage || e?.message || 'Unknown error';
        
        if (errMsg.includes('Already claimed') || errMsg.includes('already claimed')) {
          showToast('Reward already claimed!');
          claimBtn.classList.add('hidden');
        } else if (errMsg.includes('Score not high enough')) {
          showToast(`Score must be exactly ${MAX_SCORE}!`);
          claimBtn.disabled = false;
          claimBtn.innerText = 'Claim 3k BONK';
        } else if (errMsg.includes('insufficient')) {
          showToast('Contract has insufficient BONK. Contact developer!', 5000);
          claimBtn.disabled = false;
          claimBtn.innerText = 'Claim 3k BONK';
        } else if (errMsg.includes('User rejected') || errMsg.includes('rejected')) {
          showToast('Transaction cancelled by user');
          claimBtn.disabled = false;
          claimBtn.innerText = 'Claim 3k BONK';
        } else {
          showToast(`Claim failed: ${errMsg}`);
          claimBtn.disabled = false;
          claimBtn.innerText = 'Claim 3k BONK';
        }
      }
    };

    /* ---------- Share Button Handler ---------- */
    if (shareBtn) {
      shareBtn.addEventListener('click', async () => {
        try {
          shareBtn.disabled = true;
          showToast('Opening cast composer...', 3000);
          
          await sdk.actions.composeCast({
            text: `🎮 Just won 3,000 BONK tokens playing the memory game! 
Can you beat my score? 🏆

Built by @pavankumarkr`,
            embeds: [GAME_URL]
          });
          
          showToast('Cast composer opened!', 3000);
        } catch (error) {
          console.error('Share error:', error);
          showToast('Failed to open cast composer', 3000);
        } finally {
          shareBtn.disabled = false;
        }
      });
    }

    /* ---------- Audio Setup ---------- */
    const clickSound = new Audio('music.wav');
    clickSound.volume = 0.5;

    const warnSound = new Audio('warn.wav');
    warnSound.volume = 0.6;

    const winSound = new Audio('win.wav');
    winSound.volume = 0.7;

    function playClickSound() {
      clickSound.currentTime = 0;
      clickSound.play().catch(err => {
        console.log('Audio play failed:', err);
      });
    }

    function playWarnSound() {
      warnSound.currentTime = 0;
      warnSound.play().catch(err => {
        console.log('Audio play failed:', err);
      });
    }

    function playWinSound() {
      winSound.currentTime = 0;
      winSound.play().catch(err => {
        console.log('Audio play failed:', err);
      });
    }

    /* ---------- Confetti Effect ---------- */
    function createConfetti() {
      const confettiColors = ['#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6', '#e91e63', '#00bcd4'];
      const confettiCount = 100;

      for (let i = 0; i < confettiCount; i++) {
        setTimeout(() => {
          const confetti = document.createElement('div');
          confetti.className = 'confetti';
          confetti.style.left = Math.random() * 100 + 'vw';
          confetti.style.backgroundColor = confettiColors[Math.floor(Math.random() * confettiColors.length)];
          confetti.style.animationDuration = (Math.random() * 2 + 2) + 's';
          confetti.style.animationDelay = '0s';
          document.body.appendChild(confetti);

          setTimeout(() => {
            confetti.remove();
          }, 4000);
        }, i * 30);
      }
    }

    /* ---------- Timer Countdown ---------- */
    let timerInterval = null;

    function getTimeUntilMidnightUTC() {
      const now = new Date();
      const midnight = new Date(Date.UTC(
        now.getUTCFullYear(),
        now.getUTCMonth(),
        now.getUTCDate() + 1,
        0, 0, 0, 0
      ));
      const diff = midnight - now;
      
      const hours = Math.floor(diff / (1000 * 60 * 60));
      const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
      const seconds = Math.floor((diff % (1000 * 60)) / 1000);
      
      return { hours, minutes, seconds, total: diff };
    }

    function updateTimerDisplay() {
      const { hours, minutes, seconds } = getTimeUntilMidnightUTC();
      const formattedTime = `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
      startBtn.innerText = `Next game in ${formattedTime}`;
    }

    function startTimer() {
      if (timerInterval) clearInterval(timerInterval);
      
      updateTimerDisplay();
      timerInterval = setInterval(() => {
        const { total } = getTimeUntilMidnightUTC();
        
        if (total <= 0) {
          clearInterval(timerInterval);
          timerInterval = null;
          currentDailyPlays = 0;
          startBtn.disabled = false;
          updateStartButtonText(0);
          if (userAddress) {
            fetchDailyPlays(userAddress);
          }
        } else {
          updateTimerDisplay();
        }
      }, 1000);
    }

    /* ---------- Game Logic ---------- */
    const colors = [
      {name: "red", hex: "#e74c3c"},
      {name: "blue", hex: "#3498db"},
      {name: "green", hex: "#2ecc71"},
      {name: "yellow", hex: "#f39c12"},
      {name: "purple", hex: "#9b59b6"}
    ];

    let sequence = [];
    let userSequence = [];
    let round = 1;
    let displaying = false;
    let bestScore = 0;
    let buttonsEnabled = false;

    if (localStorage.getItem('bestScore')) {
      bestScore = parseInt(localStorage.getItem('bestScore'));
    }

    colors.forEach((colorObj, index) => {
      const btn = document.createElement('button');
      btn.classList.add('colorBtn');
      if (colorObj.name === 'purple') {
        btn.classList.add('purple-btn');
      }
      btn.style.backgroundColor = colorObj.hex;
      btn.innerText = colorObj.name.toUpperCase();
      btn.dataset.color = colorObj.name;
      btn.addEventListener('click', () => handleUserInput(colorObj.name, btn));
      buttonsContainer.appendChild(btn);
    });

    function updateButtons(enabled) {
      buttonsEnabled = enabled;
      document.querySelectorAll('.colorBtn').forEach(btn => {
        btn.disabled = !enabled;
      });
    }

    function sleep(ms) { 
      return new Promise(resolve => setTimeout(resolve, ms)); 
    }

    async function displaySequence() {
      displaying = true;
      updateButtons(false);
      colorDisplay.innerText = "Watch Carefully!";
      message.innerText = "";
      await sleep(800);
      
      for (let i = 0; i < sequence.length; i++) {
        const colorObj = colors.find(c => c.name === sequence[i]);
        colorDisplay.style.backgroundColor = colorObj.hex;
        colorDisplay.innerText = colorObj.name.toUpperCase();
        colorDisplay.classList.add('pulse');
        await sleep(700);
        colorDisplay.classList.remove('pulse');
        colorDisplay.style.backgroundColor = "rgba(0, 0, 0, 0.3)";
        colorDisplay.innerText = "";
        await sleep(300);
      }
      
      displaying = false;
      updateButtons(true);
      colorDisplay.innerText = "Your Turn!";
    }

    function nextRound() {
      userSequence = [];
      const randomColor = colors[Math.floor(Math.random() * colors.length)];
      sequence.push(randomColor.name);
      roundDisplay.innerText = round;
      displaySequence();
    }

    async function initGame() {
      if (!userAddress) {
        showToast("Please connect your wallet first!");
        return;
      }

      if (currentDailyPlays >= maxDailyGames) {
        showToast("You've reached your daily game limit. Come back tomorrow!");
        return;
      }

      message.innerText = `Starting Free Game... Please confirm gas transaction.`;
      updateButtons(false);
      startBtn.disabled = true;

      let hash;
      try {
        const txResponse = await writeContract(config, {
          address: CONTRACT_ADDRESS,
          abi: ABI,
          functionName: 'startGame',
          args: [],
        });

        hash = txResponse?.hash || txResponse;
        if (!hash) {
          throw new Error("Transaction not sent (hash undefined)");
        }

        showToast(`Transaction sent! Waiting for confirmation...`);
        message.innerText = `Transaction sent! Waiting for confirmation...`;

        const receipt = await publicClient.waitForTransactionReceipt({ hash });

        let gameId = null;
        let found = false;

        for (const log of receipt.logs) {
          try {
            const decoded = decodeEventLog({
              abi: ABI,
              data: log.data,
              topics: log.topics,
            });

            if (decoded.eventName === "GameStarted") {
              gameId = Number(decoded.args.gameId);
              currentGameId = gameId;
              found = true;
              break;
            }
          } catch (e) {
          }
        }

        if (!found || currentGameId === null) {
          message.innerText = `No GameStarted event found. Check TX: https://arbiscan.io/tx/${hash}`;
          showToast("Transaction confirmed but GameStarted event missing.");
          startBtn.disabled = false;
          updateStartButtonText(currentDailyPlays);
          return;
        }

        message.innerText = `Game started! Game ID: ${currentGameId}`;
        showToast(`Game started! Game ID: ${currentGameId}`);

        startBtn.classList.add('hidden');
        restartBtn.classList.remove('hidden');
        claimBtn.classList.add('hidden');
        if (shareBtn) shareBtn.style.display = 'none';
        finalScore = 0;

        currentDailyPlays++;
        updateStartButtonText(currentDailyPlays);
        nextRound();

      } catch (e) {
        console.error('Init error:', e);
        let errMsg = e?.shortMessage || e?.message || "Unknown error";
        showToast(`Start Failed: ${errMsg}`);
        message.innerText = `Transaction failed: ${errMsg}`;
        startBtn.disabled = false;
        updateStartButtonText(currentDailyPlays);
      }
    }

    async function handleUserInput(colorName, btn) {
      if (displaying || !buttonsEnabled) return;
      
      playClickSound();
      
      btn.classList.add('pressed');
      setTimeout(() => btn.classList.remove('pressed'), 300);
      
      userSequence.push(colorName);
      const currentIndex = userSequence.length - 1;
      
      if (userSequence[currentIndex] !== sequence[currentIndex]) {
        await handleGameEnd(false);
        return;
      }

      if (userSequence.length === sequence.length) {
        if (round === MAX_SCORE) {
          await handleGameEnd(true);
        } else {
          updateButtons(false);
          colorDisplay.style.backgroundColor = "#2ecc71";
          colorDisplay.innerText = "Correct!";
          round++;
          message.innerText = `Great! Round ${round} incoming...`;

          setTimeout(() => {
            colorDisplay.style.backgroundColor = "rgba(0, 0, 0, 0.3)";
            colorDisplay.innerText = "";
            nextRound();
          }, 1200);
        }
      }
    }

    async function handleGameEnd(isWin) {
      updateButtons(false);
      
      if (isWin) {
        playWinSound();
        createConfetti();
        colorDisplay.style.backgroundColor = "#f39c12";
        colorDisplay.innerText = "PERFECT!";
        message.innerText = `Amazing! You reached max score ${MAX_SCORE}!`;
      } else {
        playWarnSound();
        colorDisplay.style.backgroundColor = "#e74c3c";
        colorDisplay.innerText = "Wrong!";
        message.innerText = `Game Over! You reached round ${round}`;
      }

      if (round > bestScore) {
        bestScore = round;
        localStorage.setItem('bestScore', bestScore);
        message.innerText += ` New Best: ${round}!`;
      }

      finalScore = round;
      sequence = [];

      setTimeout(async () => {
        colorDisplay.style.backgroundColor = "rgba(0, 0, 0, 0.3)";
        colorDisplay.innerText = "Get Ready...";
        message.innerText = "";

        try {
          if (currentGameId) {
            showToast("Saving your score on-chain...");
            message.innerText = `Submitting score ${finalScore} for game ${currentGameId}...`;
            
            console.log('Submitting endGame:', {
              gameId: currentGameId,
              score: finalScore,
              scoreAsBigInt: BigInt(finalScore)
            });
            
            const txResponse = await writeContract(config, {
              address: CONTRACT_ADDRESS,
              abi: ABI,
              functionName: 'endGame',
              args: [BigInt(currentGameId), BigInt(finalScore)]
            });
            
            const endHash = txResponse?.hash || txResponse;
            if (endHash) {
              showToast(`Score TX sent! Waiting for confirmation...`);
              message.innerText = `Confirming score submission...`;
              
              await publicClient.waitForTransactionReceipt({ hash: endHash });
              showToast("Score submitted successfully!");
              
              const gameData = await readContract(config, {
                address: CONTRACT_ADDRESS,
                abi: ABI,
                functionName: 'games',
                args: [BigInt(currentGameId)]
              });
              
              const storedScore = Number(gameData[2]);
              console.log('Stored score on-chain:', storedScore);
              
              message.innerText = `Score ${storedScore} saved on-chain!`;
            }
          }

          if (finalScore === MAX_SCORE && currentGameId) {
            claimBtn.classList.remove('hidden');
            showToast(`Perfect score ${MAX_SCORE}! Click "Claim 3k BONK" to get your reward!`, 4000);
            message.innerText = `You scored ${MAX_SCORE}/7! Claim your reward!`;
          } else if (finalScore < MAX_SCORE) {
            showToast(`Good try! You scored ${finalScore}. Reach ${MAX_SCORE} for a reward.`);
            message.innerText = `Score ${finalScore} saved. Try to reach ${MAX_SCORE}!`;
          }

        } catch (e) {
          console.error('EndGame error:', e);
          let errMsg = e?.shortMessage || e?.message || "Unknown error";
          showToast(`Failed to save score: ${errMsg}`);
          message.innerText = `Could not save on-chain: ${errMsg}`;
        }
      }, 2500);
    }

    function restartGame() {
      sequence = [];
      userSequence = [];
      round = 1;
      displaying = false;
      currentGameId = null;
      finalScore = 0;
      colorDisplay.style.backgroundColor = "rgba(0, 0, 0, 0.3)";
      colorDisplay.innerText = "Get Ready...";
      message.innerText = "Ready for your next game!";
      roundDisplay.innerText = "1";
      updateButtons(false);
      restartBtn.classList.add('hidden');
      claimBtn.classList.add('hidden');
      if (shareBtn) shareBtn.style.display = 'none';
      startBtn.classList.remove('hidden');
      
      if (userAddress) {
        fetchDailyPlays(userAddress);
      } else {
        updateStartButtonText(currentDailyPlays);
      }
    }

    restartBtn.onclick = restartGame;
    startBtn.onclick = initGame;

    window.addEventListener('beforeunload', () => {
      if (timerInterval) {
        clearInterval(timerInterval);
      }
    });

    /* ---------- Neynar API Integration ---------- */
    async function fetchFarcasterUsersByAddresses(addresses) {
      if (!addresses || addresses.length === 0) return {};
      
      try {
        const addressesParam = addresses.join(',');
        const response = await fetch(
          `https://api.neynar.com/v2/farcaster/user/bulk-by-address?addresses=${addressesParam}`,
          {
            method: 'GET',
            headers: {
              'accept': 'application/json',
              'api_key': NEYNAR_API_KEY
            }
          }
        );

        if (!response.ok) {
          console.error('Neynar API error:', response.status);
          return {};
        }

        const data = await response.json();
        return data;
      } catch (error) {
        console.error('Error fetching Farcaster users:', error);
        return {};
      }
    }

    /* ---------- Leaderboard ---------- */
    async function loadLeaderboard() {
      const tbody = document.getElementById('leaderboardBody');
      tbody.innerHTML = '<tr><td colspan="3" class="center">Loading…</td></tr>';
      
      try {
        const [players, scores] = await readContract(config, {
          address: CONTRACT_ADDRESS,
          abi: ABI,
          functionName: 'getTopPlayers',
          args: [10n]
        });
        
        if (!players || players.length === 0) {
          tbody.innerHTML = '<tr><td colspan="3" class="center">No scores yet.</td></tr>';
          return;
        }

        const farcasterUsers = await fetchFarcasterUsersByAddresses(players);
        
        tbody.innerHTML = '';
        for (let i = 0; i < players.length; i++) {
          const address = players[i].toLowerCase();
          const users = farcasterUsers[address];
          
          const tr = document.createElement('tr');
          const rankTd = document.createElement('td');
          rankTd.className = 'rank-cell';
          
          if (i === 0) {
            rankTd.classList.add('gold');
            rankTd.textContent = '🥇';
          } else if (i === 1) {
            rankTd.classList.add('silver');
            rankTd.textContent = '🥈';
          } else if (i === 2) {
            rankTd.classList.add('bronze');
            rankTd.textContent = '🥉';
          } else {
            rankTd.textContent = i + 1;
          }
          
          const playerTd = document.createElement('td');
          
          if (users && users.length > 0) {
            const user = users[0];
            const pfpUrl = user.pfp_url || 'https://via.placeholder.com/32';
            const username = user.username || 'Unknown';
            const displayName = user.display_name || username;
            
            const userCell = document.createElement('div');
            userCell.className = 'user-cell';
            
            const pfpImg = document.createElement('img');
            pfpImg.src = pfpUrl;
            pfpImg.alt = username;
            pfpImg.className = 'pfp';
            pfpImg.onerror = () => {
              pfpImg.src = 'https://via.placeholder.com/32';
            };
            
            const userInfo = document.createElement('div');
            userInfo.className = 'user-info';
            
            const usernameDiv = document.createElement('div');
            usernameDiv.className = 'username';
            usernameDiv.textContent = `@${username}`;
            
            const addressDiv = document.createElement('div');
            addressDiv.className = 'address';
            addressDiv.textContent = `${players[i].slice(0, 6)}…${players[i].slice(-4)}`;
            
            userInfo.appendChild(usernameDiv);
            userInfo.appendChild(addressDiv);
            userCell.appendChild(pfpImg);
            userCell.appendChild(userInfo);
            playerTd.appendChild(userCell);
          } else {
            const shortAddress = `${players[i].slice(0, 6)}…${players[i].slice(-4)}`;
            playerTd.textContent = shortAddress;
          }
          
          const scoreTd = document.createElement('td');
          scoreTd.className = 'score-cell';
          scoreTd.textContent = scores[i].toString();
          
          tr.appendChild(rankTd);
          tr.appendChild(playerTd);
          tr.appendChild(scoreTd);
          tbody.appendChild(tr);
        }
      } catch (e) {
        console.error('Leaderboard error:', e);
        tbody.innerHTML = '<tr><td colspan="3" class="center">Failed to load leaderboard.</td></tr>';
      }
    }

    claimBtn.classList.add('hidden');
    restartBtn.classList.add('hidden');
    startBtn.classList.add('hidden');
    if (shareBtn) shareBtn.style.display = 'none';
    updateButtons(false);
    message.innerText = "Connect your wallet to begin";
  </script>
</body>
</html>