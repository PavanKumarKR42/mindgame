<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=390, initial-scale=1.0" />
  <title>Mind Color Sequence Game</title>

    <meta name="fc:miniapp" content='{
    "version":"1",
    "imageUrl":"https://mindgame-omega.vercel.app/icon.png",
    "button":{
      "title":"Memory Game",
      "action":{
        "type":"launch_frame",
        "name":"Mind Color Sequence",
        "url":"https://mindgame-omega.vercel.app/",
        "splashImageUrl":"https://mindgame-omega.vercel.app/splash.png",
        "splashBackgroundColor":"#F1C27D"
      }
    }
  }' />

  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      display: flex; flex-direction: column; align-items: center; justify-content: flex-start;
      min-height: 100vh; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; color: #fff;
      padding: 8px; max-width: 390px; margin: 0 auto; overflow-x: hidden;
    }
    .tabbar { display: flex; gap: 8px; width: 100%; margin: 8px 0; }
    .tabbar button { flex: 1; padding: 10px; background: linear-gradient(135deg, #FFD700, #FFA500); border: 3px solid #FF8C00; color: #000; border-radius: 12px; font-weight: 900; cursor: pointer; transition: all 0.3s ease; text-shadow: 1px 1px 0 rgba(255,255,255,0.5); box-shadow: 0 4px 15px rgba(255, 215, 0, 0.4), inset 0 2px 0 rgba(255,255,255,0.3); }
    .tabbar button.active { background: linear-gradient(135deg, #FF8C00, #FF6347); border-color: #FF4500; transform: scale(1.05); box-shadow: 0 6px 20px rgba(255, 69, 0, 0.6), inset 0 2px 0 rgba(255,255,255,0.3); }
    .tabbar button:hover { transform: translateY(-2px); filter: brightness(1.1); }
    .hidden { display: none; }
    .game-container { background: rgba(255, 255, 255, 0.1); backdrop-filter: blur(10px); border-radius: 20px; padding: 15px; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3); border: 1px solid rgba(255, 255, 255, 0.2); width: 100%; }
    h1 { text-align: center; margin-bottom: 8px; font-size: 22px; text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3); }
    .score-info { display: flex; justify-content: center; margin-bottom: 12px; }
    .score-box { background: rgba(255, 255, 255, 0.15); padding: 8px 12px; border-radius: 12px; text-align: center; border: 1px solid rgba(255, 255, 255, 0.2); }
    .score-label { font-size: 10px; opacity: 0.8; text-transform: uppercase; letter-spacing: 1px; }
    .score-value { font-size: 18px; font-weight: bold; margin-top: 3px; }
    #colorDisplay { width: 100%; height: 120px; border-radius: 20px; margin-bottom: 15px; border: 3px solid rgba(255, 255, 255, 0.3); display: flex; align-items: center; justify-content: center; font-size: 20px; font-weight: bold; background: rgba(0, 0, 0, 0.3); transition: all 0.3s ease; box-shadow: inset 0 4px 20px rgba(0, 0, 0, 0.2); text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5); }
    #colorDisplay.pulse { animation: pulse 0.5s ease; }
    @keyframes pulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.05); } }
    .buttons { display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; margin-bottom: 50px; position: relative; }
    .bonk-token { position: absolute; width: 50px; height: 50px; border-radius: 50%; object-fit: cover; border: 3px solid rgba(255, 215, 0, 0.8); box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4), 0 0 25px rgba(255, 215, 0, 0.5), 0 0 40px rgba(255, 215, 0, 0.2); top: 75px; left: 50%; transform: translateX(-50%); z-index: 10; animation: float 3s ease-in-out infinite; }
    @keyframes float { 0%, 100% { transform: translateX(-50%) translateY(0px); } 50% { transform: translateX(-50%) translateY(-10px); } }
    .colorBtn { height: 65px; border: 3px solid; border-radius: 20px; cursor: pointer; font-weight: 900; font-size: 14px; color: #fff; text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5); transition: all 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55); box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4), inset 0 -3px 8px rgba(0, 0, 0, 0.3), inset 0 2px 8px rgba(255, 255, 255, 0.2); position: relative; overflow: hidden; letter-spacing: 0.5px; }
    .colorBtn[data-color="red"] { border-color: #c0392b; box-shadow: 0 6px 20px rgba(231, 76, 60, 0.6), inset 0 -3px 8px rgba(0, 0, 0, 0.3), inset 0 2px 8px rgba(255, 255, 255, 0.2), 0 0 15px rgba(231, 76, 60, 0.4); }
    .colorBtn[data-color="blue"] { border-color: #2980b9; box-shadow: 0 6px 20px rgba(52, 152, 219, 0.6), inset 0 -3px 8px rgba(0, 0, 0, 0.3), inset 0 2px 8px rgba(255, 255, 255, 0.2), 0 0 15px rgba(52, 152, 219, 0.4); }
    .colorBtn[data-color="green"] { border-color: #27ae60; box-shadow: 0 6px 20px rgba(46, 204, 113, 0.6), inset 0 -3px 8px rgba(0, 0, 0, 0.3), inset 0 2px 8px rgba(255, 255, 255, 0.2), 0 0 15px rgba(46, 204, 113, 0.4); }
    .colorBtn[data-color="yellow"] { border-color: #d68910; box-shadow: 0 6px 20px rgba(243, 156, 18, 0.6), inset 0 -3px 8px rgba(0, 0, 0, 0.3), inset 0 2px 8px rgba(255, 255, 255, 0.2), 0 0 15px rgba(243, 156, 18, 0.4); }
    .colorBtn[data-color="purple"] { border-color: #7d3c98; box-shadow: 0 6px 20px rgba(155, 89, 182, 0.6), inset 0 -3px 8px rgba(0, 0, 0, 0.3), inset 0 2px 8px rgba(255, 255, 255, 0.2), 0 0 15px rgba(155, 89, 182, 0.4); }
    .colorBtn::after { content: ''; position: absolute; top: -50%; left: -50%; width: 200%; height: 200%; background: linear-gradient(45deg, transparent, rgba(255, 255, 255, 0.3), transparent); transform: rotate(45deg); transition: all 0.5s ease; }
    .colorBtn:hover:not(:disabled)::after { left: 100%; }
    .colorBtn:hover:not(:disabled) { transform: translateY(-5px) scale(1.05); box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5), 0 0 30px currentColor, inset 0 -3px 8px rgba(0, 0, 0, 0.3), inset 0 2px 8px rgba(255, 255, 255, 0.3); filter: brightness(1.15); }
    .colorBtn:active:not(:disabled) { transform: translateY(-2px) scale(0.98); box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4), inset 0 3px 8px rgba(0, 0, 0, 0.4); }
    .colorBtn:disabled { opacity: 0.4; cursor: not-allowed; filter: grayscale(0.5); }
    .colorBtn::before { content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.25), transparent 60%); opacity: 0.8; pointer-events: none; }
    .colorBtn.pressed { animation: press 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55); }
    .colorBtn.purple-btn { grid-column: 3; grid-row: 2; }
    @keyframes press { 0% { transform: scale(1) rotate(0deg); } 25% { transform: scale(0.92) rotate(-3deg); } 50% { transform: scale(0.95) rotate(2deg); filter: brightness(1.4) saturate(1.3); box-shadow: 0 0 30px currentColor; } 75% { transform: scale(0.92) rotate(-2deg); } 100% { transform: scale(1) rotate(0deg); } }
    #message { text-align: center; font-size: 16px; min-height: 25px; font-weight: 600; text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3); margin-bottom: 15px; }
    .btn-control { display: flex; gap: 8px; margin-top: 8px; }
    .restart-btn { flex: 1; padding: 12px; background: linear-gradient(135deg, #FFD700, #FFA500); border: 3px solid #FF8C00; border-radius: 15px; color: #000; font-size: 14px; font-weight: 900; cursor: pointer; transition: all 0.3s ease; text-shadow: 1px 1px 0 rgba(255,255,255,0.5); box-shadow: 0 4px 15px rgba(255, 165, 0, 0.5), inset 0 2px 0 rgba(255,255,255,0.3); }
    .restart-btn:hover { background: linear-gradient(135deg, #FFA500, #FF8C00); transform: translateY(-2px); box-shadow: 0 6px 20px rgba(255, 165, 0, 0.7); }
    .claim-btn { flex: 1; padding: 12px; background: linear-gradient(135deg, #FFD700, #FFFF00); border: 3px solid #FFD700; border-radius: 15px; color: #000; font-size: 14px; font-weight: 900; cursor: pointer; transition: all 0.3s ease; text-shadow: 1px 1px 0 rgba(255,255,255,0.5); box-shadow: 0 4px 15px rgba(255, 215, 0, 0.6), inset 0 2px 0 rgba(255,255,255,0.4); }
    .claim-btn:hover { background: linear-gradient(135deg, #FFFF00, #FFD700); transform: translateY(-2px) scale(1.02); box-shadow: 0 6px 25px rgba(255, 215, 0, 0.9), 0 0 20px rgba(255, 215, 0, 0.5); }
    table { width: 100%; border-collapse: collapse; margin-top: 12px; }
    th, td { padding: 8px; border-bottom: 1px solid rgba(255, 255, 255, 0.2); font-size: 14px; text-align: left; }
    thead { background: rgba(0, 0, 0, 0.3); }
    .center { text-align: center; }
    .toast { position: fixed; bottom: 14px; left: 50%; transform: translateX(-50%); background: rgba(255, 255, 255, 0.12); backdrop-filter: blur(8px); color: #fff; border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 14px; padding: 10px 14px; font-weight: 600; max-width: 360px; width: calc(100% - 24px); box-shadow: 0 8px 30px rgba(0, 0, 0, 0.5); display: none; z-index: 9999; }
    .toast.show { display: block; animation: fadeIn 0.25s ease; }
    @keyframes fadeIn { from { opacity: 0; transform: translate(-50%, 10px); } to { opacity: 1; transform: translate(-50%, 0); } }
    .start-btn { flex: 1; padding: 12px; background: linear-gradient(135deg, #FFD700, #FFA500); border: 3px solid #FF8C00; border-radius: 15px; color: #000; font-size: 14px; font-weight: 900; cursor: pointer; transition: all 0.3s ease; text-shadow: 1px 1px 0 rgba(255,255,255,0.5); box-shadow: 0 4px 15px rgba(255, 165, 0, 0.5), inset 0 2px 0 rgba(255,255,255,0.3); }
    .start-btn:hover { background: linear-gradient(135deg, #FFA500, #FF8C00); transform: translateY(-2px); box-shadow: 0 6px 20px rgba(255, 165, 0, 0.7); }
    h3 { text-align: center; margin-bottom: 10px; }
  </style>
</head>
<body>

  <div class="tabbar">
    <button id="tabPlayBtn" class="active">üéÆ Play</button>
    <button id="tabLbBtn">üèÜ Leaderboard</button>
  </div>

  <section id="playTab">
    <div class="game-container">
      <h1>üéØ Mind Color Sequence</h1>
      
      <div class="score-info">
        <div class="score-box">
          <div class="score-label">Round</div>
          <div class="score-value" id="roundDisplay">1</div>
        </div>
      </div>
      
      <div id="colorDisplay">GET READY</div>
      
      <div class="buttons" id="buttonsContainer">
        <img src="bonktoken.png" alt="BONK" class="bonk-token">
      </div>
      
      <div id="message"></div>
      
      <div class="btn-control">
        <button class="start-btn" id="connectBtn">üîó Connect Wallet</button>
        <button class="start-btn hidden" id="startBtn">üéÆ Start Free Game</button>
        <button class="restart-btn hidden" id="restartBtn">üîÑ Restart Game</button>
        <button class="claim-btn hidden" id="claimBtn">üí∞ Claim 3k BONK</button>
      </div>

    </div>
  </section>

  <section id="leaderboardTab" class="hidden" style="width:100%;padding:0 12px;">
    <h3>üèÜ Top 10 High Scores</h3>
    <table>
      <thead><tr><th>#</th><th>Address</th><th>Score</th></tr></thead>
      <tbody id="leaderboardBody"><tr><td colspan="3" class="center">Loading‚Ä¶</td></tr></tbody>
    </table>
  </section>

  <div id="toast" class="toast"></div>

  <script type="module">
    import { sdk } from 'https://esm.sh/@farcaster/miniapp-sdk';
    import {
      createConfig, connect, readContract, writeContract, getAccount
    } from 'https://esm.sh/@wagmi/core';
    import { arbitrum } from 'https://esm.sh/@wagmi/core/chains';
    import { farcasterMiniApp } from 'https://esm.sh/@farcaster/miniapp-wagmi-connector';
    import { createPublicClient, http } from 'https://esm.sh/viem';
    import { decodeEventLog } from 'https://esm.sh/viem';

    const CONTRACT_ADDRESS = '0xe54be4a16ec396d2c31812a3693af15281ee115a';
    const MAX_SCORE = 7;

    const ABI =[{"inputs":[{"internalType":"address","name":"_bonkToken","type":"address"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"gameId","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"score","type":"uint256"}],"name":"GameEnded","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"player","type":"address"},{"indexed":true,"internalType":"uint256","name":"gameId","type":"uint256"}],"name":"GameStarted","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"gameId","type":"uint256"}],"name":"RewardClaimed","type":"event"},{"inputs":[],"name":"MAX_DAILY_GAMES","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"MAX_SCORE","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"REWARD","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"","type":"uint256"}],"name":"allPlayers","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"bonkToken","outputs":[{"internalType":"contract IERC20","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"gameId","type":"uint256"}],"name":"claim","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"dailyPlays","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"gameId","type":"uint256"},{"internalType":"uint256","name":"score","type":"uint256"}],"name":"endGame","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"","type":"uint256"}],"name":"games","outputs":[{"internalType":"address","name":"player","type":"address"},{"internalType":"bool","name":"ended","type":"bool"},{"internalType":"uint256","name":"score","type":"uint256"},{"internalType":"bool","name":"claimed","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"n","type":"uint256"}],"name":"getTopPlayers","outputs":[{"internalType":"address[]","name":"","type":"address[]"},{"internalType":"uint256[]","name":"","type":"uint256[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"lastDay","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"nextGameId","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"startGame","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"userTotalScore","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"withdraw","outputs":[],"stateMutability":"nonpayable","type":"function"}];

    const config = createConfig({
      chains: [arbitrum],
      transports: { [arbitrum.id]: http() }
    });

    const publicClient = createPublicClient({
      chain: arbitrum,
      transport: http()
    });

    const playTab = document.getElementById('playTab');
    const leaderboardTab = document.getElementById('leaderboardTab');
    const tabPlayBtn = document.getElementById('tabPlayBtn');
    const tabLbBtn = document.getElementById('tabLbBtn');
    const toastEl = document.getElementById('toast');
    const claimBtn = document.getElementById('claimBtn');
    const restartBtn = document.getElementById('restartBtn');
    const startBtn = document.getElementById('startBtn');
    const connectBtn = document.getElementById('connectBtn');
    const colorDisplay = document.getElementById('colorDisplay');
    const buttonsContainer = document.getElementById('buttonsContainer');
    const message = document.getElementById('message');
    const roundDisplay = document.getElementById('roundDisplay');

    let userAddress = null;
    let currentGameId = null;
    let currentDailyPlays = 0;
    let maxDailyGames = 3;
    let finalScore = 0;

    tabPlayBtn.onclick = () => {
      playTab.classList.remove('hidden');
      leaderboardTab.classList.add('hidden');
      tabPlayBtn.classList.add('active');
      tabLbBtn.classList.remove('active');
    };

    tabLbBtn.onclick = () => {
      leaderboardTab.classList.remove('hidden');
      playTab.classList.add('hidden');
      tabLbBtn.classList.add('active');
      tabPlayBtn.classList.remove('active');
      loadLeaderboard();
    };

    function showToast(html, ms = 3500) {
      toastEl.innerHTML = html;
      toastEl.classList.add('show');
      setTimeout(() => toastEl.classList.remove('show'), ms);
    }

    function updateStartButtonText(dailyPlays) {
      if (dailyPlays < maxDailyGames) {
        startBtn.innerText = `üéÆ Start Free Game (${dailyPlays}/${maxDailyGames})`;
      } else {
        startBtn.innerText = `‚è∞ Daily Limit Reached`;
        startBtn.disabled = true;
      }
    }

   async function fetchDailyPlays(address) {
      try {
        const currentDay = Math.floor(Date.now() / 1000 / 86400);
        
        const lastDay = await readContract(config, {
          address: CONTRACT_ADDRESS,
          abi: ABI,
          functionName: 'lastDay',
          args: [address]
        });
        
        if (Number(lastDay) < currentDay) {
          currentDailyPlays = 0;
        } else {
          const count = await readContract(config, {
            address: CONTRACT_ADDRESS,
            abi: ABI,
            functionName: 'dailyPlays',
            args: [address]
          });
          currentDailyPlays = Number(count);
        }
        
        updateStartButtonText(currentDailyPlays);
      } catch (e) {
        console.error('Failed to fetch daily plays:', e);
        currentDailyPlays = 0;
        updateStartButtonText(currentDailyPlays);
      }
    }

    async function fetchMaxDailyGames() {
      try {
        const max = await readContract(config, {
          address: CONTRACT_ADDRESS,
          abi: ABI,
          functionName: 'MAX_DAILY_GAMES'
        });
        maxDailyGames = Number(max);
      } catch (e) {
        console.error('Failed to fetch MAX_DAILY_GAMES:', e);
        maxDailyGames = 3;
      }
    }

    sdk.actions.ready({ disableNativeGestures: true }).then(() => {
      console.log("Farcaster MiniApp ready");
      message.innerText = "Ready to connect!";
    }).catch(err => {
      console.error("SDK ready error:", err);
      message.innerText = "SDK initialization failed";
      showToast("Failed to initialize. Try reloading.");
    });

    connectBtn.onclick = async () => {
      try {
        connectBtn.disabled = true;
        connectBtn.innerText = 'üîó Connecting...';
        message.innerText = "Connecting wallet...";

        await connect(config, {
          connector: farcasterMiniApp(),
          chainId: arbitrum.id
        });

        userAddress = getAccount(config)?.address;

        if (userAddress) {
          showToast(`‚úÖ Connected: ${userAddress.slice(0, 6)}‚Ä¶${userAddress.slice(-4)}`);
          
          await fetchMaxDailyGames();
          await fetchDailyPlays(userAddress);

          connectBtn.classList.add('hidden');
          startBtn.classList.remove('hidden');
          colorDisplay.innerText = "Get Ready...";
          message.innerText = "Wallet connected. Ready to play!";
        } else {
          throw new Error("No address returned");
        }
      } catch (err) {
        console.error("Wallet connect failed:", err);
        showToast("‚ùå Connect failed. Make sure you opened this in Warpcast.");
        connectBtn.disabled = false;
        connectBtn.innerText = 'üîó Connect Wallet';
        message.innerText = "Connection failed. Try again.";
      }
    };

    claimBtn.onclick = async () => {
      if (!currentGameId) {
        showToast('‚ùå No active game to claim. Play and win first!');
        return;
      }
      
      if (finalScore !== MAX_SCORE) {
        showToast(`‚ùå Score must be exactly ${MAX_SCORE} to claim. You scored ${finalScore}.`);
        return;
      }
      
      try {
        claimBtn.disabled = true;
        claimBtn.innerText = 'üîç Checking...';
        
        const gameData = await readContract(config, {
          address: CONTRACT_ADDRESS,
          abi: ABI,
          functionName: 'games',
          args: [BigInt(currentGameId)]
        });
        
        console.log('Game data:', gameData);
        const [player, ended, score, claimed] = gameData;
        
        if (claimed) {
          showToast('‚ö†Ô∏è Reward already claimed for this game!');
          claimBtn.classList.add('hidden');
          claimBtn.disabled = false;
          claimBtn.innerText = 'üí∞ Claim 3k BONK';
          return;
        }
        
        if (!ended) {
          showToast('‚è≥ Game not ended yet. Please wait.');
          claimBtn.disabled = false;
          claimBtn.innerText = 'üí∞ Claim 3k BONK';
          return;
        }
        
        if (Number(score) !== MAX_SCORE) {
          showToast(`‚ùå Score is ${Number(score)}, must be exactly ${MAX_SCORE} to claim!`);
          claimBtn.disabled = false;
          claimBtn.innerText = 'üí∞ Claim 3k BONK';
          return;
        }
        
        const bonkAddress = await readContract(config, {
          address: CONTRACT_ADDRESS,
          abi: ABI,
          functionName: 'bonkToken'
        });
        
        const contractBalance = await readContract(config, {
          address: bonkAddress,
          abi: [{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"balanceOf","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"}],
          functionName: 'balanceOf',
          args: [CONTRACT_ADDRESS]
        });
        
        console.log('Contract BONK balance:', contractBalance.toString());
        
        const requiredReward = 3000000n;
        if (contractBalance < requiredReward) {
          showToast('‚ö†Ô∏è Contract has insufficient BONK tokens. Contact developer to refill!', 5000);
          claimBtn.disabled = false;
          claimBtn.innerText = 'üí∞ Claim 3k BONK';
          return;
        }
        
        claimBtn.innerText = 'üí∞ Claiming...';
        const { hash } = await writeContract(config, {
          address: CONTRACT_ADDRESS,
          abi: ABI,
          functionName: 'claim',
          args: [BigInt(currentGameId)]
        });
        showToast(`‚úÖ Claim TX sent! <a target="_blank" href="https://arbiscan.io/tx/${hash}" style="color: #FFD700; text-decoration: underline;">View TX</a>`, 5000);
        
        await publicClient.waitForTransactionReceipt({ hash });
        showToast(`üéâ Reward claimed successfully!`, 4000);
        
        claimBtn.classList.add('hidden');
        claimBtn.disabled = false;
        claimBtn.innerText = 'üí∞ Claim 3k BONK';
      } catch (e) {
        console.error('Claim error:', e);
        let errMsg = e?.shortMessage || e?.message || 'Unknown error';
        
        if (errMsg.includes('Already claimed')) {
          showToast('‚ö†Ô∏è Reward already claimed!');
          claimBtn.classList.add('hidden');
        } else if (errMsg.includes('Score not high enough')) {
          showToast(`‚ùå Score must be exactly ${MAX_SCORE}!`);
        } else if (errMsg.includes('insufficient')) {
          showToast('‚ö†Ô∏è Contract has insufficient BONK. Contact developer!', 5000);
        } else {
          showToast(`‚ùå Claim failed: ${errMsg}`);
        }
        
        claimBtn.disabled = false;
        claimBtn.innerText = 'üí∞ Claim 3k BONK';
      }
    };

    const colors = [
      {name: "red", hex: "#e74c3c"},
      {name: "blue", hex: "#3498db"},
      {name: "green", hex: "#2ecc71"},
      {name: "yellow", hex: "#f39c12"},
      {name: "purple", hex: "#9b59b6"}
    ];

    let sequence = [];
    let userSequence = [];
    let round = 1;
    let displaying = false;
    let bestScore = 0;
    let buttonsEnabled = false;

    colors.forEach((colorObj, index) => {
      const btn = document.createElement('button');
      btn.classList.add('colorBtn');
      if (colorObj.name === 'purple') {
        btn.classList.add('purple-btn');
      }
      btn.style.backgroundColor = colorObj.hex;
      btn.innerText = colorObj.name.toUpperCase();
      btn.dataset.color = colorObj.name;
      btn.addEventListener('click', () => handleUserInput(colorObj.name, btn));
      buttonsContainer.appendChild(btn);
    });

    function updateButtons(enabled) {
      buttonsEnabled = enabled;
      document.querySelectorAll('.colorBtn').forEach(btn => {
        btn.disabled = !enabled;
      });
    }

    function sleep(ms) { 
      return new Promise(resolve => setTimeout(resolve, ms)); 
    }

    async function displaySequence() {
      displaying = true;
      updateButtons(false);
      colorDisplay.innerText = "Watch Carefully!";
      message.innerText = "";
      await sleep(800);
      
      for (let i = 0; i < sequence.length; i++) {
        const colorObj = colors.find(c => c.name === sequence[i]);
        colorDisplay.style.backgroundColor = colorObj.hex;
        colorDisplay.innerText = colorObj.name.toUpperCase();
        colorDisplay.classList.add('pulse');
        await sleep(700);
        colorDisplay.classList.remove('pulse');
        colorDisplay.style.backgroundColor = "rgba(0, 0, 0, 0.3)";
        colorDisplay.innerText = "";
        await sleep(300);
      }
      
      displaying = false;
      updateButtons(true);
      colorDisplay.innerText = "Your Turn!";
    }

    function nextRound() {
      userSequence = [];
      const randomColor = colors[Math.floor(Math.random() * colors.length)];
      sequence.push(randomColor.name);
      roundDisplay.innerText = round;
      displaySequence();
    }

    async function initGame() {
      if (!userAddress) {
        showToast("‚ùå Please connect your wallet first!");
        return;
      }

      if (currentDailyPlays >= maxDailyGames) {
        showToast("‚è∞ You've reached your daily game limit. Come back tomorrow!");
        return;
      }

      message.innerText = `üéÆ Starting Free Game... Please confirm gas transaction.`;
      updateButtons(false);
      startBtn.disabled = true;

      let hash;
      try {
        const txResponse = await writeContract(config, {
          address: CONTRACT_ADDRESS,
          abi: ABI,
          functionName: 'startGame',
          args: [],
        });

        hash = txResponse?.hash || txResponse;
        if (!hash) {
          throw new Error("Transaction not sent (hash undefined)");
        }

        showToast(`‚úÖ Transaction sent! Waiting for confirmation...`);
        message.innerText = `‚è≥ Transaction sent! Waiting for confirmation...`;

        const receipt = await publicClient.waitForTransactionReceipt({ hash });

        let gameId = null;
        let found = false;

        for (const log of receipt.logs) {
          try {
            const decoded = decodeEventLog({
              abi: ABI,
              data: log.data,
              topics: log.topics,
            });

            if (decoded.eventName === "GameStarted") {
              gameId = Number(decoded.args.gameId);
              currentGameId = gameId;
              found = true;
              break;
            }
          } catch (e) {
          }
        }

        if (!found || currentGameId === null) {
          message.innerText = `‚ö†Ô∏è No GameStarted event found. Check TX: https://arbiscan.io/tx/${hash}`;
          showToast("‚ö†Ô∏è Transaction confirmed but GameStarted event missing.");
          startBtn.disabled = false;
          updateStartButtonText(currentDailyPlays);
          return;
        }

        message.innerText = `üéÆ Game started! Game ID: ${currentGameId}`;
        showToast(`üéâ Game started! Game ID: ${currentGameId}`);

        startBtn.classList.add('hidden');
        restartBtn.classList.remove('hidden');
        claimBtn.classList.add('hidden');
        finalScore = 0;

        currentDailyPlays++;
        updateStartButtonText(currentDailyPlays);
        nextRound();

      } catch (e) {
        console.error('Init error:', e);
        let errMsg = e?.shortMessage || e?.message || "Unknown error";
        showToast(`‚ùå Start Failed: ${errMsg}`);
        message.innerText = `‚ùå Transaction failed: ${errMsg}`;
        startBtn.disabled = false;
        updateStartButtonText(currentDailyPlays);
      }
    }

    async function handleUserInput(colorName, btn) {
      if (displaying || !buttonsEnabled) return;
      
      btn.classList.add('pressed');
      setTimeout(() => btn.classList.remove('pressed'), 300);
      
      userSequence.push(colorName);
      const currentIndex = userSequence.length - 1;
      
      if (userSequence[currentIndex] !== sequence[currentIndex]) {
        await handleGameEnd(false);
        return;
      }

      if (userSequence.length === sequence.length) {
        if (round === MAX_SCORE) {
          await handleGameEnd(true);
        } else {
          updateButtons(false);
          colorDisplay.style.backgroundColor = "#2ecc71";
          colorDisplay.innerText = "‚úÖ Correct!";
          round++;
          message.innerText = `üéØ Great! Round ${round} incoming...`;

          setTimeout(() => {
            colorDisplay.style.backgroundColor = "rgba(0, 0, 0, 0.3)";
            colorDisplay.innerText = "";
            nextRound();
          }, 1200);
        }
      }
    }

    async function handleGameEnd(isWin) {
      updateButtons(false);
      
      if (isWin) {
        colorDisplay.style.backgroundColor = "#f39c12";
        colorDisplay.innerText = "üéâ PERFECT!";
        message.innerText = `üèÜ Amazing! You reached max score ${MAX_SCORE}!`;
      } else {
        colorDisplay.style.backgroundColor = "#e74c3c";
        colorDisplay.innerText = "‚ùå Wrong!";
        message.innerText = `üíÄ Game Over! You reached round ${round}`;
      }

      if (round > bestScore) {
        bestScore = round;
        message.innerText += ` üÜï New Best: ${round}!`;
      }

      finalScore = round;
      sequence = [];

      setTimeout(async () => {
        colorDisplay.style.backgroundColor = "rgba(0, 0, 0, 0.3)";
        colorDisplay.innerText = "Get Ready...";
        message.innerText = "";

        try {
          if (currentGameId) {
            showToast("üíæ Saving your score on-chain...");
            message.innerText = `üìù Submitting score ${finalScore} for game ${currentGameId}...`;
            
            console.log('Submitting endGame:', {
              gameId: currentGameId,
              score: finalScore,
              scoreAsBigInt: BigInt(finalScore)
            });
            
            const txResponse = await writeContract(config, {
              address: CONTRACT_ADDRESS,
              abi: ABI,
              functionName: 'endGame',
              args: [BigInt(currentGameId), BigInt(finalScore)]
            });
            
            const endHash = txResponse?.hash || txResponse;
            if (endHash) {
              showToast(`‚úÖ Score TX sent! Waiting for confirmation...`);
              message.innerText = `‚è≥ Confirming score submission...`;
              
              await publicClient.waitForTransactionReceipt({ hash: endHash });
              showToast("‚úÖ Score submitted successfully!");
              
              const gameData = await readContract(config, {
                address: CONTRACT_ADDRESS,
                abi: ABI,
                functionName: 'games',
                args: [BigInt(currentGameId)]
              });
              
              const storedScore = Number(gameData[2]);
              console.log('Stored score on-chain:', storedScore);
              
              message.innerText = `‚úÖ Score ${storedScore} saved on-chain!`;
            }
          }

          if (finalScore === MAX_SCORE && currentGameId) {
            claimBtn.classList.remove('hidden');
            showToast(`üéâ Perfect score ${MAX_SCORE}! Click "Claim 3k BONK" to get your reward!`, 4000);
            message.innerText = `üèÜ You scored ${MAX_SCORE}/7! Claim your reward!`;
          } else if (finalScore < MAX_SCORE) {
            showToast(`üëç Good try! You scored ${finalScore}. Reach ${MAX_SCORE} for a reward.`);
            message.innerText = `üìä Score ${finalScore} saved. Try to reach ${MAX_SCORE}!`;
          }

        } catch (e) {
          console.error('EndGame error:', e);
          let errMsg = e?.shortMessage || e?.message || "Unknown error";
          showToast(`‚ùå Failed to save score: ${errMsg}`);
          message.innerText = `‚ùå Could not save on-chain: ${errMsg}`;
        }
      }, 2500);
    }

    function restartGame() {
      sequence = [];
      userSequence = [];
      round = 1;
      displaying = false;
      currentGameId = null;
      finalScore = 0;
      colorDisplay.style.backgroundColor = "rgba(0, 0, 0, 0.3)";
      colorDisplay.innerText = "Get Ready...";
      message.innerText = "Ready for your next game!";
      roundDisplay.innerText = "1";
      updateButtons(false);
      restartBtn.classList.add('hidden');
      claimBtn.classList.add('hidden');
      startBtn.classList.remove('hidden');
      startBtn.disabled = false;
      
      if (userAddress) {
        fetchDailyPlays(userAddress);
      } else {
        updateStartButtonText(currentDailyPlays);
      }
    }

    restartBtn.onclick = restartGame;
    startBtn.onclick = initGame;

    async function loadLeaderboard() {
      const tbody = document.getElementById('leaderboardBody');
      tbody.innerHTML = '<tr><td colspan="3" class="center">‚è≥ Loading‚Ä¶</td></tr>';
      try {
        const [players, scores] = await readContract(config, {
          address: CONTRACT_ADDRESS,
          abi: ABI,
          functionName: 'getTopPlayers',
          args: [10n]
        });
        tbody.innerHTML = '';
        if (!players || players.length === 0) {
          tbody.innerHTML = '<tr><td colspan="3" class="center">No scores yet.</td></tr>';
          return;
        }
        for (let i = 0; i < players.length; i++) {
          const short = `${players[i].slice(0, 6)}‚Ä¶${players[i].slice(-4)}`;
          const tr = document.createElement('tr');
          tr.innerHTML = `<td>${i + 1}</td><td>${short}</td><td>${scores[i].toString()}</td>`;
          tbody.appendChild(tr);
        }
      } catch (e) {
        tbody.innerHTML = '<tr><td colspan="3" class="center">‚ùå Failed to load leaderboard.</td></tr>';
      }
    }

    claimBtn.classList.add('hidden');
    restartBtn.classList.add('hidden');
    startBtn.classList.add('hidden');
    updateButtons(false);
    message.innerText = "Connect your wallet to begin";
  </script>
</body>
</html>